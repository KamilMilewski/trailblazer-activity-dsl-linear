require "test_helper"

#:intermediate
  def a(x=1)
  end
#:intermediate end

class LinearTest < Minitest::Spec
  Right = Class.new#Trailblazer::Activity::Right
  Left = Class.new#Trailblazer::Activity::Right
  PassFast = Class.new#Trailblazer::Activity::Right

  Process = Trailblazer::Activity::Process
  Inter = Trailblazer::Activity::Process::Intermediate
  Activity = Trailblazer::Activity

  Linear = Trailblazer::Activity::DSL::Linear

  let(:implementing) do
    implementing = Module.new do
      extend T.def_tasks(:a, :b, :c, :d)
    end
    implementing::Start = Activity::Start.new(semantic: :default)
    implementing::Failure = Activity::End(:failure)
    implementing::Success = Activity::End(:success)

    implementing
  end

  it do
    # generated by the editor or a specific DSL.
    # DISCUSS: is this considered DSL-independent code?
    # TODO: unique {id}
    # Intermediate shall not contain actual object references, since it might be generated.
    intermediate = Inter.new({
        Inter::TaskRef(:a) => [Inter::Out(:success, :b), Inter::Out(:failure, :c)],
        Inter::TaskRef(:b) => [Inter::Out(:success, :d), Inter::Out(:failure, :c)],
        Inter::TaskRef(:c) => [Inter::Out(:success, "End.failure"), Inter::Out(:failure, "End.failure")],
        Inter::TaskRef(:d) => [Inter::Out(:success, "End.success"), Inter::Out(:failure, "End.success")],
        Inter::TaskRef("End.success", stop_event: true) => [],
        Inter::TaskRef("End.failure", stop_event: true) => [],
      },
      [Inter::TaskRef("End.success"), Inter::TaskRef("End.failure")],
      [Inter::TaskRef(:a)] # start
    )

    implementation = {
      :a => Process::Implementation::Task(implementing.method(:a), [Activity::Output(Right,       :success), Activity::Output(Left, :failure)]),
      :b => Process::Implementation::Task(implementing.method(:b), [Activity::Output("B/success", :success), Activity::Output("B/failure", :failure)]),
      :c => Process::Implementation::Task(implementing.method(:c), [Activity::Output(Right,       :success), Activity::Output(Left, :failure)]),
      :d => Process::Implementation::Task(implementing.method(:d), [Activity::Output("D/success", :success), Activity::Output(Left, :failure)]),
      "End.success" => Process::Implementation::Task(implementing::Success, [Activity::Output(implementing::Success, :success)]), # DISCUSS: End has one Output, signal is itself?
      "End.failure" => Process::Implementation::Task(implementing::Failure, [Activity::Output(implementing::Failure, :failure)]),
    }

    circuit = Inter.circuit(intermediate, implementation)
    pp circuit

    nodes = Inter.node_attributes(implementation)
    # generic NodeAttributes
    pp nodes

    outputs = Inter.outputs(intermediate.stop_task_refs, nodes)
    pp outputs

    process = Trailblazer::Activity::Process.new(circuit, outputs, nodes)

    puts cct = Trailblazer::Developer::Render::Circuit.(process: process)

    cct.must_equal %{
#<Method: #<Module:0x>.a>
 {LinearTest::Right} => #<Method: #<Module:0x>.b>
 {LinearTest::Left} => #<Method: #<Module:0x>.c>
#<Method: #<Module:0x>.b>
 {B/success} => #<Method: #<Module:0x>.d>
 {B/failure} => #<Method: #<Module:0x>.c>
#<Method: #<Module:0x>.c>
 {LinearTest::Right} => #<End/:failure>
 {LinearTest::Left} => #<End/:failure>
#<Method: #<Module:0x>.d>
 {D/success} => #<End/:success>
 {LinearTest::Left} => #<End/:success>
#<End/:success>

#<End/:failure>
}
  end

  # outputs = task.outputs / default

          # default #step
      # :success=>[Right, :success]=>[Search.method(:Forward), :success]
          # override by user
      # :success=>[Right, :success]=>[Search.method(:ById), :blaId]

  # default {step}: Output(outputs[:success].signal, outputs[:success].semantic)=>[Search::Forward, :success], ...
  # compile effective Output(signal, semantic) => Search::<strat>

  it "DSL to change {Sequence} and compile it to a {Process}" do
    def default_binary_outputs
      {success: Trailblazer::Activity::Output(Trailblazer::Activity::Right, :success), failure: Trailblazer::Activity::Output(Trailblazer::Activity::Left, :failure)}
    end

    def default_step_connections
      {success: [Linear::Search.method(:Forward), :success], failure: [Linear::Search.method(:Forward), :failure]}
    end

    @sequence = Linear::Sequence.new

    def step(task, magnetic_to: :success, outputs: self.default_binary_outputs, connections: self.default_step_connections, **local_options)
      add_task_to_sequence!(magnetic_to, task, sequence: @sequence, outputs: outputs, connections: connections, **local_options)
    end

    def add_task_to_sequence!(*args, &block)
      @sequence = add_task(*args, &block)
    end

    def add_task(track, task, outputs:, connections:, sequence:, **local_options)
      # TODO: allow replace, inherit etc!
      sequence += [[
        track,
        task,
        # DISCUSS: shouldn't we be going through the outputs here?
        # TODO: or warn if an output is unconnected.
        connections.collect do |semantic, (search_strategy, *search_args)|
          output = outputs[semantic] || raise("No `#{semantic}` output found for #{outputs.inspect}")

          search_strategy.(
            output,
            *search_args
          )
        end,
        local_options # {id: "Start.success"}
      ]]
    end


    start_default = Activity::Start.new(semantic: :default)
    end_success   = Activity::End.new(semantic: :success)
    end_failure   = Activity::End.new(semantic: :failure)


    step(start_default, id: "Start.default", outputs: {success: default_binary_outputs[:success]}, connections: {success: default_step_connections[:success]})


    step(implementing.method(:a), id: :a)
    step(implementing.method(:b), id: :b)


    step(end_success, id: "End.success", outputs: {success: end_success}, connections: {success: [Linear::Search.method(:Noop)]})
    step(end_failure, magnetic_to: :failure, id: "End.failure", outputs: {failure: end_failure}, connections: {failure: [Linear::Search.method(:Noop)]})

pp @sequence
    process = Linear::Compiler.(@sequence)

    cct = Trailblazer::Developer::Render::Circuit.(process: process)
    puts cct
  end

  it "simple linear approach where a {Sequence} is compiled into an Intermediate/Implementation" do
    seq = [
      [
        nil,
        implementing::Start,
        [
          Linear::Search::Forward(
            Activity::Output(Right, :success),
            :success
          ),
        ],
        {id: "Start.default"},
      ],
      [
        :success, # MinusPole
        # [Search::Forward(:success), Search::ById(:a)]
        implementing.method(:a),
        [
          Linear::Search::Forward(
            Activity::Output(Right, :success),
            :success
          ),
          Linear::Search::Forward(
            Activity::Output(Left, :failure),
            :failure
          ),
        ],
        {id: :a},
      ],
      [
        :success,
        implementing.method(:b),
        [
          Linear::Search::Forward(
            Activity::Output("B/success", :success),
            :success
          ),
          Linear::Search::Forward(
            Activity::Output("B/failure", :failure),
            :failure
          )
        ],
        {id: :b},
      ],
      [
        :failure,
        implementing.method(:c),
        [
          Linear::Search::Forward(
            Activity::Output(Right, :success),
            :failure
          ),
          Linear::Search::Forward(
            Activity::Output(Left, :failure),
            :failure
         )
        ],
        {id: :c},
      ],
      [
        :success,
        implementing.method(:d),
        [
          Linear::Search::Forward(
            Activity::Output("D/success", :success),
            :success
          ),
          Linear::Search::Forward(
            Activity::Output(Left, :failure),
            :failure
          )
        ],
        {id: :d},
      ],
      [
        :success,
        implementing::Success,
        [
          Linear::Search::Noop(
            Activity::Output(implementing::Success, :success)
          )
        ],
        {id: "End.success", stop_event: true},
      ],
      [
        :failure,
        implementing::Failure,
        [
          Linear::Search::Noop(
            Activity::Output(implementing::Failure, :failure)
          )
        ],
        {id: "End.failure", stop_event: true},
      ],
    ]

    process = Linear::Compiler.(seq)

    cct = Trailblazer::Developer::Render::Circuit.(process: process)

    cct.must_equal %{
#<Start/:default>
 {LinearTest::Right} => #<Method: #<Module:0x>.a>
#<Method: #<Module:0x>.a>
 {LinearTest::Right} => #<Method: #<Module:0x>.b>
 {LinearTest::Left} => #<Method: #<Module:0x>.c>
#<Method: #<Module:0x>.b>
 {B/success} => #<Method: #<Module:0x>.d>
 {B/failure} => #<Method: #<Module:0x>.c>
#<Method: #<Module:0x>.c>
 {LinearTest::Right} => #<End/:failure>
 {LinearTest::Left} => #<End/:failure>
#<Method: #<Module:0x>.d>
 {D/success} => #<End/:success>
 {LinearTest::Left} => #<End/:failure>
#<End/:success>

#<End/:failure>
}

  end
end

# TODO: test when target can't be found
