require "test_helper"

module Trailblazer::Activity::DSL
  class Intermediate < Struct.new(:wiring, :stop_tasks, :start_tasks)

# FIXME: move those back to Activity::Structure
    NodeAttributes = Struct.new(:id, :outputs, :task, :data)
    Process = Struct.new(:circuit, :outputs, :nodes)

    # Intermediate structures
    Node = Struct.new(:id) # TODO: rename to NodeRef
    # Outs = Class.new(Hash)
    Out  = Struct.new(:semantic, :target)

    # module_function


    # Implementation structures
    Task = Struct.new(:circuit_task, :outputs)

    # From the intermediate "template" and the actual implementation, compile a {Circuit} instance.
    def self.circuit(intermediate, implementation)
      wiring = Hash[
        intermediate.wiring.collect do |node, outs|
          task = implementation.fetch(node.id)

          [
            task.circuit_task,
            Hash[ # compute the connections for {circuit_task}.
              outs.collect { |required_out|
                [
                  for_semantic(task.outputs, required_out.semantic).signal,
                  implementation.fetch(required_out.target).circuit_task
                ]
              }
            ]
          ]
        end
      ]

      Trailblazer::Circuit.new(
        wiring,
        intermediate.stop_tasks.collect { |node| implementation.fetch(node.id).circuit_task },
        start_task: intermediate.start_tasks.collect { |node| implementation.fetch(node.id).circuit_task }[0]
      )
    end

    # DISCUSS: this is intermediate-independent?
    def self.node_attributes(implementation, nodes_data={}) # TODO: process {nodes_data}
      implementation.collect do |id, task| # id, Task{circuit_task, outputs}
        NodeAttributes.new(id, task.outputs, task.circuit_task, {})
      end
    end

    def self.outputs(stop_tasks, nodes_attributes)
      stop_tasks.collect do |task_ref|
        stop_event = nodes_attributes.find { |node_attrs| task_ref.id == node_attrs.id }.task

        Trailblazer::Activity::Output(stop_event, stop_event.to_h[:semantic]) # DISCUSS: how could we pass the semantic without disassembling?
      end
    end

    private

    # Apply to any array.
    def self.for_semantic(ary, semantic)
      ary.find { |out| out.semantic == semantic } or raise "`#{semantic}` not found"
    end
  end

  module Linear
  end
end

class LinearTest < Minitest::Spec
  Right = Class.new#Trailblazer::Activity::Right
  Left = Class.new#Trailblazer::Activity::Right
  PassFast = Class.new#Trailblazer::Activity::Right

  Inter = Trailblazer::Activity::DSL::Intermediate
  Activity = Trailblazer::Activity

  it do
    # generated by the editor or a specific DSL.
    # DISCUSS: is this considered DSL-independent code?
    # TODO: unique {id}
    intermediate = Inter.new({
        Inter::Node.new(:a) => [Inter::Out.new(:success, :b), Inter::Out.new(:failure, :c)],
        Inter::Node.new(:b) => [Inter::Out.new(:success, :d), Inter::Out.new(:failure, :c)],
        Inter::Node.new(:c) => [Inter::Out.new(:success, "End.failure"), Inter::Out.new(:failure, "End.failure")],
        Inter::Node.new(:d) => [Inter::Out.new(:success, "End.success"), Inter::Out.new(:failure, "End.success")],
        Inter::Node.new("End.success") => [],
        Inter::Node.new("End.failure") => [],
      },
      [Inter::Node.new("End.success"), Inter::Node.new("End.failure")],
      [Inter::Node.new(:a)]
    ) # start_nodes: [:a]

    implementing = Module.new do
      extend T.def_tasks(:a, :b, :c, :d)
    end
    implementing::Failure = Activity::End(:failure)
    implementing::Success = Activity::End(:success)

    implementation = {
      :a => Inter::Task.new(implementing.method(:a), [Activity::Output(Right,       :success), Activity::Output(Left, :failure)]),
      :b => Inter::Task.new(implementing.method(:b), [Activity::Output("B/success", :success), Activity::Output("B/failure", :failure)]),
      :c => Inter::Task.new(implementing.method(:c), [Activity::Output(Right,       :success), Activity::Output(Left, :failure)]),
      :d => Inter::Task.new(implementing.method(:d), [Activity::Output("D/success", :success), Activity::Output(Left, :failure)]),
      "End.success" => Inter::Task.new(implementing::Success, []),
      "End.failure" => Inter::Task.new(implementing::Failure, []),
    }

    nodes = Inter.node_attributes(implementation)
    # generic NodeAttributes
    pp nodes

    outputs = Inter.outputs(intermediate.stop_tasks, nodes)

    pp outputs

    circuit = Inter.circuit(intermediate, implementation)
    pp circuit

    process = Inter::Process.new(circuit, outputs, nodes)

    puts cct = Trailblazer::Developer::Render::Circuit.(process: process)

    cct.must_equal %{
#<Method: #<Module:0x>.a>
 {LinearTest::Right} => #<Method: #<Module:0x>.b>
 {LinearTest::Left} => #<Method: #<Module:0x>.c>
#<Method: #<Module:0x>.b>
 {B/success} => #<Method: #<Module:0x>.d>
 {B/failure} => #<Method: #<Module:0x>.c>
#<Method: #<Module:0x>.c>
 {LinearTest::Right} => #<End/:failure>
 {LinearTest::Left} => #<End/:failure>
#<Method: #<Module:0x>.d>
 {D/success} => #<End/:success>
 {LinearTest::Left} => #<End/:success>
#<End/:success>

#<End/:failure>
}
  end
end
